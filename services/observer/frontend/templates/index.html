<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>BGP Observer</title>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <script src="https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.6/dist/dist/vis-network.min.css" />
    <link rel="stylesheet" href="/static/style.css" />
    <style>
      #bgp-graph {
        width: 100%;
        height: 500px;
        border: 1px solid #ddd;
        background: #f9f9f9;
      }
      .bgp-routes-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 15px;
      }
      .routes-table-container {
        max-height: 500px;
        overflow-y: auto;
      }
      .route-hijacked {
        background-color: #ffebee;
      }
      .route-normal {
        background-color: #e8f5e9;
      }
      @media (max-width: 768px) {
        .bgp-routes-container {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>BGP Attack Lab Observer</h1>
      <div id="active-scenario-badge" style="display: inline-block; margin-left: 20px; padding: 10px 20px; border-radius: 5px; font-weight: bold;">
        Loading...
      </div>
      <button id="refresh-status" class="btn btn-secondary">Refresh status</button>
    </header>
    <main>
      <section id="status-panel" class="card">
        <div id="status-alert" class="alert" hidden></div>
        <div id="status-content">
          <p>Click "Refresh status" to load lab details.</p>
        </div>
      </section>
      <section class="card">
        <h2>Topology overview</h2>
        <div id="topology-panel">
          <p>Loading topology metadataâ€¦</p>
        </div>
      </section>
      <section class="card">
        <h2>PCAP files</h2>
        <div id="pcap-panel">
          <p>Loading pcap filesâ€¦</p>
        </div>
      </section>
      <section class="card">
        <h2>BGP Routes Visualization</h2>
        <div id="bgp-routes-panel">
          <p>Loading BGP routesâ€¦</p>
        </div>
      </section>
    </main>
    <script>
      async function loadTopology() {
        const container = document.getElementById("topology-panel");
        if (!container) {
          return;
        }
        try {
          const resp = await fetch("/api/topology");
          if (!resp.ok) {
            let errorMessage = `Failed to load topology (${resp.status})`;
            try {
              const errorPayload = await resp.json();
              if (typeof errorPayload.detail === "string") {
                errorMessage = errorPayload.detail;
              }
            } catch (err) {
              /* ignore parse errors */
            }
            throw new Error(errorMessage);
          }
          const data = await resp.json();
          container.innerHTML = renderTopology(data);
        } catch (error) {
          container.innerHTML = `<p class="error">${error.message}</p>`;
        }
      }

      function renderTopology(topology) {
        const routerRows = topology.routers
          .map(
            (router) => `
          <tr>
            <td>${router.name}</td>
            <td>${router.asn}</td>
            <td>${router.role}</td>
            <td>${router.networks.join("<br/>") || "â€“"}</td>
            <td>${router.peers.join(", ") || "â€“"}</td>
          </tr>`
          )
          .join("");
        const linkRows = Object.entries(topology.links)
          .map(
            ([name, link]) => `
          <tr>
            <td>${name}</td>
            <td>${link.ipv4_subnet}</td>
          </tr>`
          )
          .join("");
        return `
        <p><strong>${topology.lab_name}</strong> â€” ${topology.description}</p>
        <div class="topology-grid">
          <div>
            <h3>Routers</h3>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>ASN</th>
                  <th>Role</th>
                  <th>Networks</th>
                  <th>Peers</th>
                </tr>
              </thead>
              <tbody>
                ${routerRows || '<tr><td colspan="5">No routers defined.</td></tr>'}
              </tbody>
            </table>
          </div>
          <div>
            <h3>Links</h3>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>IPv4 subnet</th>
                </tr>
              </thead>
              <tbody>
                ${linkRows || '<tr><td colspan="2">No links defined.</td></tr>'}
              </tbody>
            </table>
          </div>
        </div>`;
      }

      loadTopology();
      setInterval(loadTopology, 60000);

      const statusContent = document.getElementById("status-content");
      const statusAlert = document.getElementById("status-alert");
      const pcapPanel = document.getElementById("pcap-panel");

      function escapeHtml(value) {
        const safeValue = value ?? "";
        return String(safeValue)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function clearStatusAlert() {
        statusAlert.textContent = "";
        statusAlert.hidden = true;
        statusAlert.className = "alert";
      }

      function showStatusAlert(message, variant = "success") {
        statusAlert.textContent = message;
        statusAlert.className = `alert alert-${variant}`;
        statusAlert.hidden = false;
      }

      function renderStatus(status) {
        const scenarioRows = (status.scenarios || [])
          .map(
            (scenario) => `
            <tr>
              <td>${escapeHtml(scenario.name)}</td>
              <td>${escapeHtml(scenario.description)}</td>
              <td class="scenario-actions">
                <button
                  class="btn btn-primary"
                  data-scenario="${escapeHtml(scenario.name)}"
                  onclick="activateScenario(this.dataset.scenario)"
                >Activate</button>
              </td>
            </tr>`
          )
          .join("");
        const routerList = (status.routers || [])
          .map((router) => `<li>${escapeHtml(router)}</li>`)
          .join("");
        return `
          <div class="status-grid">
            <div>
              <h3>Scenarios</h3>
              <table>
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Description</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody>
                  ${
                    scenarioRows ||
                    '<tr><td colspan="3">No scenarios published by the Attack Controller.</td></tr>'
                  }
                </tbody>
              </table>
            </div>
            <div>
              <h3>Routers</h3>
              <ul class="router-list">
                ${routerList || '<li>No routers defined in lab_config.yaml.</li>'}
              </ul>
            </div>
          </div>
        `;
      }

      function renderPcaps(payload) {
        const files = payload.files || [];
        if (files.length === 0) {
          return "<p>No pcap files.</p>";
        }
        const items = files
          .map(
            (file) =>
              `<li><a href="/captures/${encodeURIComponent(file)}" download>${escapeHtml(
                file,
              )}</a></li>`
          )
          .join("");
        return `<ul class="pcap-list">${items}</ul>`;
      }

      async function loadPcaps() {
        if (!pcapPanel) {
          return;
        }
        try {
          const resp = await fetch("/api/pcaps");
          if (!resp.ok) {
            throw new Error(`Failed to load pcap files (${resp.status})`);
          }
          const data = await resp.json();
          pcapPanel.innerHTML = renderPcaps(data);
        } catch (error) {
          pcapPanel.innerHTML = `<p class="error">${escapeHtml(error.message)}</p>`;
        }
      }

      function updateScenarioBadge(activeScenario) {
        const badge = document.getElementById("active-scenario-badge");
        if (!badge) return;

        if (activeScenario === "normal") {
          badge.textContent = "ðŸŸ¢ NORMAL";
          badge.style.backgroundColor = "#4CAF50";
          badge.style.color = "white";
        } else {
          badge.textContent = `ðŸ”´ ACTIVE: ${activeScenario}`;
          badge.style.backgroundColor = "#f44336";
          badge.style.color = "white";
        }
      }

      async function loadStatus() {
        if (!statusContent) {
          return;
        }
        try {
          const resp = await fetch("/api/status");
          if (!resp.ok) {
            throw new Error(`Failed to load status (${resp.status})`);
          }
          const data = await resp.json();
          statusContent.innerHTML = renderStatus(data);

          // Update active scenario badge
          if (data.active_scenario) {
            updateScenarioBadge(data.active_scenario);
          }

          clearStatusAlert();
        } catch (error) {
          statusContent.innerHTML = `<p class="error">${error.message}</p>`;
          showStatusAlert(error.message, "error");
        }
      }

      async function activateScenario(name) {
        if (!name) {
          return;
        }
        showStatusAlert(`Activating scenario "${name}"â€¦`, "info");
        try {
          const resp = await fetch(`/api/scenario/${encodeURIComponent(name)}`, {
            method: "POST",
          });
          const payload = await resp.json().catch(() => ({}));
          const detail = payload.detail || payload.message || `Scenario "${name}" activated.`;
          if (!resp.ok) {
            throw new Error(detail);
          }
          showStatusAlert(detail, "success");
          await loadStatus();
        } catch (error) {
          showStatusAlert(error.message, "error");
        }
      }

      window.activateScenario = activateScenario;

      const refreshButton = document.getElementById("refresh-status");
      if (refreshButton) {
        refreshButton.addEventListener("click", () => {
          loadStatus();
        });
      }

      loadStatus();
      loadPcaps();
      setInterval(loadPcaps, 30000);

      // BGP Routes Visualization
      const bgpRoutesPanel = document.getElementById("bgp-routes-panel");
      let bgpNetwork = null;

      async function loadBGPRoutes() {
        if (!bgpRoutesPanel) {
          return;
        }
        try {
          const resp = await fetch("/api/bgp_routes");
          if (!resp.ok) {
            throw new Error(`Failed to load BGP routes (${resp.status})`);
          }
          const data = await resp.json();
          renderBGPRoutes(data);
        } catch (error) {
          bgpRoutesPanel.innerHTML = `<p class="error">${escapeHtml(error.message)}</p>`;
        }
      }

      function renderBGPRoutes(data) {
        const routesHtml = renderRoutesTable(data.routes);
        const graphHtml = '<div id="bgp-graph"></div>';

        bgpRoutesPanel.innerHTML = `
          <div class="bgp-routes-container">
            <div class="routes-table-container">
              <h3>BGP Routes Table</h3>
              ${routesHtml}
            </div>
            <div>
              <h3>AS-PATH Topology Graph</h3>
              ${graphHtml}
            </div>
          </div>
        `;

        // Render graph after DOM update
        setTimeout(() => renderTopologyGraph(data), 100);
      }

      function renderRoutesTable(routes) {
        if (!routes || Object.keys(routes).length === 0) {
          return '<p>No BGP routes available</p>';
        }

        let tableHtml = '<table><thead><tr><th>Router</th><th>Prefix</th><th>Paths</th><th>Status</th></tr></thead><tbody>';

        for (const [routerName, routerData] of Object.entries(routes)) {
          const routerRoutes = routerData.routes || {};
          for (const [prefix, paths] of Object.entries(routerRoutes)) {
            const isHijacked = paths.length > 1;
            const rowClass = isHijacked ? 'route-hijacked' : 'route-normal';
            const status = isHijacked ? 'ðŸ”´ HIJACK DETECTED' : 'ðŸŸ¢ Normal';

            const pathsHtml = paths.map(path => {
              const bestMarker = path.best ? '*> ' : '   ';
              const asPathStr = path.as_path.join(' â†’ ') || 'local';
              return `${bestMarker}AS ${asPathStr} (via ${path.nexthop})`;
            }).join('<br/>');

            tableHtml += `<tr class="${rowClass}">
              <td>${escapeHtml(routerName)}</td>
              <td><strong>${escapeHtml(prefix)}</strong></td>
              <td><small>${pathsHtml}</small></td>
              <td>${status}</td>
            </tr>`;
          }
        }

        tableHtml += '</tbody></table>';
        return tableHtml;
      }

      function renderTopologyGraph(data) {
        const container = document.getElementById('bgp-graph');
        if (!container) return;

        const topology = data.topology || {};
        const nodes = topology.nodes || [];
        const edges = topology.edges || [];

        // Create nodes with colors based on role
        const visNodes = nodes.map(node => {
          let color = '#97C2FC';
          if (node.role === 'edge') color = '#7BE141';
          if (node.role === 'core') color = '#FFA500';
          if (node.role === 'transit') color = '#FB7E81';

          return {
            id: node.id,
            label: node.label,
            color: {background: color, border: '#2B7CE9'},
            font: {size: 14},
            shape: 'box',
          };
        });

        // Create edges
        const visEdges = edges.map(edge => ({
          from: edge.from,
          to: edge.to,
          color: {color: '#848484'},
          width: 2,
        }));

        // Highlight hijacked paths
        const routes = data.routes || {};
        for (const [routerName, routerData] of Object.entries(routes)) {
          const routerRoutes = routerData.routes || {};
          for (const [prefix, paths] of Object.entries(routerRoutes)) {
            if (paths.length > 1) {
              // Multiple paths = hijack
              paths.forEach(path => {
                if (!path.best && path.as_path.length > 0) {
                  // Highlight hijack path in red
                  const lastAS = parseInt(path.as_path[path.as_path.length - 1]);
                  visEdges.push({
                    from: lastAS,
                    to: edges.find(e => e.from === lastAS || e.to === lastAS)?.to || lastAS,
                    color: {color: '#ff0000'},
                    width: 4,
                    dashes: true,
                    label: `HIJACK: ${prefix}`,
                    font: {color: '#ff0000', size: 12},
                  });
                }
              });
            }
          }
        }

        const networkData = {
          nodes: new vis.DataSet(visNodes),
          edges: new vis.DataSet(visEdges),
        };

        const options = {
          nodes: {
            shape: 'box',
            margin: 10,
            widthConstraint: {minimum: 100, maximum: 150},
          },
          edges: {
            smooth: {type: 'continuous'},
            arrows: {to: {enabled: false}},
          },
          physics: {
            enabled: true,
            barnesHut: {
              gravitationalConstant: -8000,
              springConstant: 0.04,
              springLength: 150,
            },
            stabilization: {iterations: 200},
          },
          interaction: {
            hover: true,
            tooltipDelay: 200,
          },
        };

        if (bgpNetwork) {
          bgpNetwork.destroy();
        }
        bgpNetwork = new vis.Network(container, networkData, options);
      }

      // Load BGP routes initially and refresh every 10 seconds
      loadBGPRoutes();
      setInterval(loadBGPRoutes, 10000);
    </script>
  </body>
</html>
